#!/usr/bin/env -S gawk -f

# copyright (c) 2025 klinoklaz infentrilnuk@yandex.com
# published under MIT license

# xmlchk v0.1.1
# XML syntax validator, requires gawk version >= 4.0

BEGIN {
    FS = "<"
    original_record = ""
    # push when encounter a start tag,
    # pop when encounter an end tag
    t_top = 0
    tag_stack[t_top] = ""
    tag_begin_at[t_top][1] = 0
    # track syntax structures that can cross multiple lines
    c_top = 0
    context_stack[c_top] = "d" # doc
    context_begin_at[c_top][1] = 0
}

{
    original_record = $0
    start = next_token(1, 1) # left side of the delimiter '<'

    for (i = 2; i <= NF; i++) { # WARNING: i is global
        ctx = context_stack[c_top]
        # '<' is a valid character in comment/PI,
        # so both can cross multiple fields
        if (ctx == "c" || ctx == "i") {
            start = next_token(i, start)
            continue
        }
        # DTD can have comments in its interior,
        # if it's not a comment, then assume it's DTD subset
        if (ctx == "!" && $i !~ /^!--/) {
            start = push_context("!", i, start)
            continue
        }
        # now at right side of the delimiter '<'
        if (ctx != "t" && ctx != "d" && ctx != "!") {
            error("unexpected '<' inside another tag", start - 1)
        }
        switch ($i) {
        case /^!--/:
            # trim leading '!--'
            # to avoid interfering with check_comment()
            $i = substr($i, 4)
            start = push_context("c", i, start + 3)
            continue
        case /^!/:
            start = push_context("!", i, start)
            continue
        case /^?/:
            # same logic as '!--'
            $i = substr($i, 2)
            start = push_context("?", i, start + 1)
            continue
        case /^\//:
            # check_end_tag() assumes leading '/' being trimmed
            $i = substr($i, 2)
            start = push_context("e", i, start + 1, 1)
            continue
        default:
            start = push_context("s", i, start)
            continue
        }
    }
}

END	{
    if (t_top) {
        error(sprintf("unexpected EOF, element not closed by end tag " \
            "(started at line %d, char %d: <%s>)",
            tag_begin_at[t_top][1], tag_begin_at[t_top][2], tag_stack[t_top]), start)
    }
    if (c_top) {
        begin_at = context_begin_at[c_top][2]
        ctx = context_stack[c_top]
        # calc the position of '<'
        begin_at = ctx == "c" \
            ? begin_at - 4 \
            : (ctx == "?" || ctx == "e" ? begin_at - 2 : begin_at - 1)
        error(sprintf("unexpected EOF, syntax structure not closed " \
            "(started at line %d, char %d)",
            context_begin_at[c_top][1], begin_at), start)
    }
}

# extract syntax structures from beginning of field `i` according to context,
# check the syntax, then remove it from $i.
# return a non-zero value indicates current char position in original $0
function next_token(i, start) {
    switch (context_stack[c_top]) {
    case "c":
        return check_comment(i, start)
    case "s":
        return check_start_tag(i, start)
    case "a":
        return check_att_list(i, start)
    case "n":
        return check_att_name(i, start)
    case "=":
        return check_att_equal(i, start)
    case "q":
        return check_att_quote(i, start)
    case "'":
    case "\"":
        return check_att_value(i, start)
    case "t":
        return check_text(i, start)
    case "e":
        return check_end_tag(i, start)
    case " ":
        return check_end_space(i, start)
    case "?":
        return check_pi_target(i, start)
    case "i":
        return check_pi_end(i, start)
    case "!":
        return skip_dtd(i, start)
    case "d":
        if (match($i, /\S/)) {
            start += RSTART - 1
            error("text outside the root element", start)
        }
        return start + length($i) + 1
    default:
        error("invalid context: "context_stack[c_top], start)
    }
}

# will be called inside the check functions,
# essentially makes next_token() an indirect recursion
function push_context(context, i, start, is_replace) {
    if (! is_replace) {
        c_top++
    }
    context_stack[c_top] = context
    context_begin_at[c_top][1] = FNR
    context_begin_at[c_top][2] = start
    return next_token(i, start)
}

# same as push_context()
function pop_context(i, start) {
    delete context_stack[c_top]
    delete context_begin_at[c_top--]
    return next_token(i, start)
}

function push_tag(tag, start) {
    tag_stack[++t_top] = tag
    tag_begin_at[t_top][1] = FNR
    tag_begin_at[t_top][2] = start - 1 # position of '<'
}

function pop_tag(no_check, tag, start) {
    if (! no_check && t_top < 1) {
        error("end tag doesn't match any start tag", start)
    }
    if (! no_check && tag != tag_stack[t_top]) {
        error(sprintf("<%s> at line %d, char %d mismatches with </%s>",
            tag_stack[t_top], tag_begin_at[t_top][1], tag_begin_at[t_top][2], tag), start)
    }
    delete tag_stack[t_top]
    delete tag_begin_at[t_top--]
}

function error(msg, start) {
    printf "%s: line %d, char %d: %s\n", FILENAME, FNR, start, msg > "/dev/stderr"
    printf "%s: line %d:\t%s\n",
        FILENAME, FNR, substr(original_record, start - 9, 20) > "/dev/stderr"
    width = start < 10 ? start : 10
    printf "%s: line %d:\t%"width"s\n", FILENAME, FNR, "^" > "/dev/stderr"
    c_top = t_top = 0 # skip the END block
    exit 1
}

# find invald character in name.
# didn't cover the full range because unicode sequences are troublesome in awk.
# see https://www.w3.org/TR/xml/#NT-Name
function invalid_name(name) {
    if (name ~ /^[\x00-\x40\x5B-\x5E\x60\x7B-\x7F]/) {
        return 1
    }
    # 'ns:na:me' should be invalid, 'ns:name' should be valid
    sub(/:/, "c", name) # get rid of first colon
    return match(name, /[\x00-\x2C\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/)
}

# find invald character in reference name.
# assume the delimiter '&' is already trimmed
function invalid_ref(ref) {
    # character ref
    if (ref ~ /^#[0-9]+;/ || ref ~ /^#x[0-9a-fA-F]+;/) {
        return 0
    }
    # entity ref
    if (ref ~ /^[\x00-\x40\x5B-\x5E\x60\x7B-\x7F]/ || ! (semi = index(ref, ";"))) {
        return 1
    }
    # everything before first ';' is the name part
    ref = substr(ref, 1, semi - 1)
    return match(ref, /[\x00-\x2C\x2F\x3A\x3C-\x40\x5B-\x5E\x60\x7B-\x7F]/)
}

function check_comment(i, start) {
    # can't get out yet, continue with next field or line
    if (! (dash = index($i, "--"))) {
        return start + length($i) + 1
    }
    cmt_end = index($i, "-->")
    # note '---->' is invalid but '--->' is fine
    if (! cmt_end || dash < cmt_end - 1) {
        error("illegal '--' inside comment", start + dash - 1)
    }
    $i = substr($i, cmt_end + 3)
    return pop_context(i, start + cmt_end + 3)
}

function check_start_tag(i, start) {
    # note empty-element tags end with '/>'
    if (match($i, /\s|>|\/>/)) {
        stag = substr($i, 1, RSTART - 1)
        trim_len = RSTART - 1
    } else {
        stag = $i
        trim_len = length($i)
    }
    if (stag == "") {
        error("malformed start tag", start)
    }
    if (inv = invalid_name(stag)) {
        error("illegal character in tag name", start + inv - 1)
    }
    push_tag(stag, start)
    $i = substr($i, trim_len + 1)
    return push_context("a", i, start + trim_len, 1)
}

function check_att_list(i, start) {
    # trim leading spaces
    start += length($i)
    sub(/^\s*/, "", $i)
    start -= length($i)
    if ($i == "") {
        return start + 1
    }
    # try to get out from current tag
    if ($i ~ /^>/) {
        $i = substr($i, 2)
        return push_context("t", i, ++start, 1)
    }
    if ($i ~ /^\/>/) {
        pop_tag(1)
        $i = substr($i, 3)
        return pop_context(i, start + 2)
    }
    # encounter attribute name
    return push_context("n", i, start)
}

function check_att_name(i, start) {
    # assume no leading space
    if (match($i, /\s|=/)) {
        att_name = substr($i, 1, RSTART - 1)
        trim_len = RSTART - 1
    } else {
        att_name = $i
        trim_len = length($i)
    }
    if (att_name == "") {
        error("malformed attribute", start)
    }
    if (inv = invalid_name(att_name)) {
        error("illegal character in attribute name", start + inv - 1)
    }
    $i = substr($i, trim_len + 1)
    # now at left side of '='
    return push_context("=", i, start + trim_len, 1)
}

# wait for an '='
function check_att_equal(i, start) {
    start += length($i)
    sub(/^\s*/, "", $i)
    start -= length($i)
    if ($i == "") {
        return start + 1
    }
    if ($i !~ /^=/) {
        error("expecting '=' after attribute name", start)
    }
    $i = substr($i, 2)
    # now at right side of '='
    return push_context("q", i, ++start, 1)
}

# wait for a quote
function check_att_quote(i, start) {
    start += length($i)
    sub(/^\s*/, "", $i)
    start -= length($i)
    if ($i == "") {
        return start + 1
    }
    if ($i !~ /^["']/) {
        error("unquoted attribute value", start)
    }
    delimiter = substr($i, 1, 1)
    $i = substr($i, 2)
    # now inside attr value
    return push_context(delimiter, i, ++start, 1)
}

function check_att_value(i, start) {
    if (quote = index($i, context_stack[c_top])) {
        val_len = quote - 1
        val = substr($i, 1, val_len)
    } else {
        val = $i
        val_len = length($i)
    }
    check_ref(val, start)
    start += val_len + 1
    if (! quote) {
        return start
    }
    # trim the value string and also the delimiter
    $i = substr($i, val_len + 2)
    if ($i !~ /^(\s|>|\/>|$)/) {
        error("attribute list not separated by space", start)
    }
    return pop_context(i, start)
}

# check for illegal '&' and ']]>' inside char data
function check_text(i, start) {
    if ((cd = index($i, "]]>"))) {
        error("CDATA end delimiter inside text", start + cd - 1)
    }
    check_ref($i, start)
    return start + length($i) + 1
}

# check for invalid '&' in char data or attr value
function check_ref(data, start) {
    split(data, ref_arr, "&")
    start += length(ref_arr[1]) + 1
    delete ref_arr[1]
    for (k in ref_arr) {
        if (inv = invalid_ref(ref_arr[k])) {
            error("bad reference", start + inv - 1)
        }
        start += length(ref_arr[k]) + 1
    }
}

function check_end_tag(i, start) {
    tag = (gt_sign = index($i, ">")) \
        ? substr($i, 1, gt_sign - 1) \
        : $i
    sub(/\s*$/, "", tag)
    pop_tag(0, tag, start)
    if (gt_sign) {
        $i = substr($i, gt_sign + 1)
        return pop_context(i, start + gt_sign)
    }
    # inside the trailing space
    start += length($i) + 1
    $i = ""
    return push_context(" ", i, start, 1)
}

# end tag ::= </name\s*>, check for the \s* part
function check_end_space(i, start) {
    end_space = (tag_end = index($i, ">")) \
        ? substr($i, 1, tag_end - 1) \
        : $i
    if (match(end_space, /\S/)) {
        error("malformed end tag", start + RSTART - 1)
    }
    if (! tag_end) {
        return start + length($i) + 1
    }
    $i = substr($i, tag_end + 1)
    return pop_context(i, start + tag_end)
}

function check_pi_target(i, start) {
    # assume the leading '<?' already trimmed
    if (match($i, /\s|?>/)) {
        pi_sep = RSTART
        pi_target = substr($i, 1, pi_sep - 1)
    } else {
        pi_sep = length($i) + 1
        pi_target = $i
    }
    if (pi_target == "") {
        error("malformed PI target", start)
    }
    # TODO: full XML declaration syntax check
    if (pi_target == "xml" && (FNR != 1 || start != 3)) {
        error("XML declaration at wrong position", start - 2)
    }
    if (inv = invalid_name(pi_target)) {
        error("illegal character in PI target", start + inv - 1)
    }
    start += pi_sep - 1
    $i = substr($i, pi_sep)
    if ($i ~ /^?>/) {
        $i = substr($i, 3)
        return pop_context(i, start + 2)
    }
    # this detects the second '<' in '<?tar<get'
    if ($i == "" && NF > i) {
        error("illegal character in PI target", start)
    }
    # now inside the instruction part
    return push_context("i", i, start, 1)
}

# everything is valid in this part of PI, nothing to check,
# just wait for '?>'
function check_pi_end(i, start) {
    if (! (pi_end = index($i, "?>"))) {
        return start + length($i) + 1
    }
    $i = substr($i, pi_end + 2)
    return pop_context(i, start + pi_end + 1)
}

# skip DTD/CDATA
function skip_dtd(i, start) {
    if (! (dtd_end = index($i, ">"))) {
        return start + length($i) + 1
    }
    $i = substr($i, dtd_end + 1)
    return pop_context(i, start + dtd_end)
}
