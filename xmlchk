#!/usr/bin/env -S gawk -f

BEGIN {
    FS = "<"
    original_record = ""
    # push when encounter a start tag,
    # pop when encounter an end tag
    t_top = 0
    tag_stack[t_top] = ""
    tag_begin_at[t_top][1] = 0
    # track syntax structures that can cross multiple lines
    c_top = 0
    context_stack[c_top] = "d" # doc
    context_begin_at[c_top][1] = 0
}

{
    original_record = $0
    start = next_token(1, 1) # left side of '<'

    for (j = 2; j <= NF; j++) {
        ctx = context_stack[c_top]
        # unknown bug: iteration index variable can be modified
        # if passed directly to the following functions
        i = j
        # '<' is a valid character in comment/PI,
        # so both can cross multiple fields
        if (ctx == "c" || ctx == "?") {
            start = next_token(i, start)
            continue
        }
        # DTD can have comments in its interior,
        # if it's not a comment, then assume it's DTD subset
        if (ctx == "!" && $i !~ /^!--/) {
            start = push_context("!", i, start)
            continue
        }
        # now at right side of the delimiter '<'
        if (ctx != "t" && ctx != "d") {
            error("unexpected '<' inside another tag", start - 1)
        }
        switch ($i) {
        case /^!--/:
            # trim leading '!--'
            # to avoid interfering with check_comment()
            $i = substr($i, 4)
            start = push_context("c", i, start + 3)
            continue
        case /^!/:
            start = push_context("!", i, start)
            continue
        case /^?/:
            # same logic as '!--'
            $i = substr($i, 2)
            start = push_context("?", i, start + 1)
            continue
        case /^\//:
            # check_end_tag() assumes leading '/' is trimmed
            $i = substr($i, 2)
            start = push_context("e", i, start + 1, 1)
            continue
        default:
            # unknown bug: this can cause `i` being modified
            # after the function returns (GNU Awk 5.2.1)
            start = push_context("s", i, start)
            continue
        }
    }
}

# extract syntax structures from beginning of field `i` according to context,
# check the syntax, then remove it from $i.
# return a non-zero value indicates current char position in original $0
function next_token(i, start) {
    switch (context_stack[c_top]) {
    case "c":
        return check_comment(i, start)
    case "s":
        return check_start_tag(i, start)
    case "a":
        return check_att_list(i, start)
    case "n":
        return check_att_name(i, start)
    case "=":
        return check_att_equal(i, start)
    case "q":
        return check_att_quote(i, start)
    case "'":
    case "\"":
        return check_att_value(i, start)
    case "t":
        return check_text(i, start)
    case "e":
        return check_end_tag(i, start)
    case " ":
        return check_end_space(i, start)
    case "?":
        return skip_pi(i, start)
    case "!":
        return skip_dtd(i, start)
    case "d":
        if (match($i, /\S/)) {
            start += RSTART - 1
            error("text outside the root element", start)
        }
        return start + length($i) + 1
    default:
        error("invalid context: "context_stack[c_top], start)
    }
}

# will be called inside the check functions,
# essentially makes next_token() an indirect recursion
function push_context(context, i, start, is_replace) {
    if (! is_replace) {
        c_top++
    }
    context_stack[c_top] = context
    context_begin_at[c_top][1] = NR
    context_begin_at[c_top][2] = start
    return next_token(i, start)
}

# same as push_context()
function pop_context(i, start) {
    delete context_stack[c_top]
    delete context_begin_at[c_top--]
    return next_token(i, start)
}

function push_tag(tag, start) {
    tag_stack[++t_top] = tag
    tag_begin_at[t_top][1] = NR
    tag_begin_at[t_top][2] = start - 1 # position of '<'
}

function pop_tag(no_check, tag, start) {
    if (! no_check && t_top < 1) {
        error("end tag doesn't match any start tag", start)
    }
    if (! no_check && tag != tag_stack[t_top]) {
        error(sprintf("<%s> at line %d, char %d mismatches with </%s>",
            tag_stack[t_top], tag_begin_at[t_top][1], tag_begin_at[t_top][2], tag), start)
    }
    delete tag_stack[t_top]
    delete tag_begin_at[t_top--]
}

function error(msg, start) {
    printf "%s: line %d, char %d: %s\n", FILENAME, NR, start, msg > "/dev/stderr"
    printf "%s: line %d: %s\n",
        FILENAME, NR, substr(original_record, start - 9, 20) > "/dev/stderr"
    width = start < 10 ? start : 10
    printf "%s: line %d: %"width"s\n", FILENAME, NR, "^" > "/dev/stderr"
    exit 1
}

# find invald character in name.
# didn't cover the full range because unicode sequences are troublesome in awk.
# see https://www.w3.org/TR/xml/#NT-Name
function invalid_name(name) {
    if (name ~ /^[\x00-\x40\x5B-\x5E\x60\x7B-\x7F]/) {
        return 1
    }
    # 'ns:na:me' should be invalid, 'ns:name' should be valid
    sub(/:/, "c", name) # get rid of first colon
    return match(name, /[\x00-\x2C\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/)
}

# find invald character in reference name.
# assume the delimiter '&' is already trimmed
function invalid_ref(ref) {
    # character ref
    if (ref ~ /^#[0-9]+;/ || ref ~ /^#x[0-9a-fA-F]+;/) {
        return 0
    }
    # entity ref
    if (ref ~ /^[\x00-\x40\x5B-\x5E\x60\x7B-\x7F]/ || ! (n = index(ref, ";"))) {
        return 1
    }
    # everything before first ';' is the name part
    ref = substr(ref, 1, n - 1)
    return match(ref, /[\x00-\x2C\x2F\x3A\x3C-\x40\x5B-\x5E\x60\x7B-\x7F]/)
}

function check_comment(i, start) {
    # can't get out yet, continue with next field or line
    if (! (n = index($i, "--"))) {
        return start + length($i) + 1
    }
    cmt_end = index($i, "-->")
    # note '---->' is invalid but '--->' is fine
    if (! cmt_end || n < cmt_end - 1) {
        error("illegal '--' inside comment", start + n - 1)
    }
    $i = substr($i, cmt_end + 3)
    return pop_context(i, start + cmt_end + 3)
}

function check_start_tag(i, start) {
    # note empty-element tags end with '/>'
    if (match($i, /\s|>|\/>/)) {
        tag = substr($i, 1, RSTART - 1)
        trim_len = RSTART - 1
    } else {
        tag = $i
        trim_len = length($i)
    }
    if (tag == "") {
        error("malformed start tag", start)
    }
    if (inv = invalid_name(tag)) {
        error("illegal character in tag name", start + inv - 1)
    }
    push_tag(tag, start)
    $i = substr($i, trim_len + 1)
    return push_context("a", i, start + trim_len, 1)
}

function check_att_list(i, start) {
    # trim leading spaces
    start += length($i)
    sub(/^\s*/, "", $i)
    start -= length($i)
    if ($i == "") {
        return start + 1
    }
    # try to get out from current tag
    if ($i ~ /^>/) {
        $i = substr($i, 2)
        return push_context("t", i, ++start, 1)
    }
    if ($i ~ /^\/>/) {
        pop_tag(1)
        $i = substr($i, 3)
        return pop_context(i, start + 2)
    }
    # encounter attribute name
    return push_context("n", i, start)
}

function check_att_name(i, start) {
    # assume no leading space
    if (match($i, /\s|=/)) {
        att_name = substr($i, 1, RSTART - 1)
        trim_len = RSTART - 1
    } else {
        att_name = $i
        trim_len = length($i)
    }
    if (att_name == "") {
        error("malformed attribute", start)
    }
    if (inv = invalid_name(att_name)) {
        error("illegal character in attribute name", start + inv - 1)
    }
    $i = substr($i, trim_len + 1)
    # now at left side of '='
    return push_context("=", i, start + trim_len, 1)
}

# wait for an '='
function check_att_equal(i, start) {
    start += length($i)
    sub(/^\s*/, "", $i)
    start -= length($i)
    if ($i == "") {
        return start + 1
    }
    if ($i !~ /^=/) {
        error("expecting '=' after attribute name", start)
    }
    $i = substr($i, 2)
    # now at right side of '='
    return push_context("q", i, ++start, 1)
}

# wait for a quote
function check_att_quote(i, start) {
    start += length($i)
    sub(/^\s*/, "", $i)
    start -= length($i)
    if ($i == "") {
        return start + 1
    }
    if ($i !~ /^["']/) {
        error("unquoted attribute value", start)
    }
    delimiter = substr($i, 1, 1)
    $i = substr($i, 2)
    # now inside attr value
    return push_context(delimiter, i, ++start, 1)
}

function check_att_value(i, start) {
    delimiter = context_stack[c_top]
    if (d = index($i, delimiter)) {
        val_len = d - 1
        val = substr($i, 1, val_len)
    } else {
        val = $i
        val_len = length($i)
    }
    check_ref(val, start)
    start += val_len + 1
    if (! d) {
        return start
    }
    # trim the value string and also the delimiter
    $i = substr($i, val_len + 2)
    if ($i !~ /^(\s|>|\/>|$)/) {
        error("attribute list not separated by space", start)
    }
    return pop_context(i, start)
}

# check for illegal '&' and ']]>' inside char data
function check_text(i, start) {
    if ((n = index($i, "]]>"))) {
        error("CDATA end delimiter inside text", start + n - 1)
    }
    check_ref($i, start)
    return start + length($i) + 1
}

# check for invalid '&' in char data or attr value
function check_ref(data, start) {
    ref_cnt = split(data, arr, "&")
    start += length(arr[1]) + 1
    for (i = 2; i <= ref_cnt; i++) {
        if (inv = invalid_ref(arr[i])) {
            error("bad reference", start + inv - 1)
        }
        start += length(arr[i]) + 1
    }
}

function check_end_tag(i, start) {
    tag = (n = index($i, ">")) ? substr($i, 1, n - 1) : $i
    sub(/\s*$/, "", tag)
    pop_tag(0, tag, start)
    if (! n) { # inside the trailing space
        return push_context(" ", i, start, 1)
    }
    $i = substr($i, n + 1)
    return pop_context(i, start + n)
}

# end tag ::= </name\s*>, check for the \s* part
function check_end_space(i, start) {
    s = (n = index($i, ">")) ? substr($i, 1, n - 1) : $i
    if (match(s, /\S/)) {
        error("malformed end tag", start + RSTART - 1)
    }
    if (! n) {
        return start + length($i) + 1
    }
    $i = substr($i, n + 1)
    return pop_context(i, start + n)
}

# skip PI/prolog
function skip_pi(i, start) {
    if (! (n = index($i, "?>"))) {
        return start + length($i) + 1
    }
    $i = substr($i, n + 2)
    return pop_context(i, start + n + 1)
}

# skip DTD/CDATA
function skip_dtd(i, start) {
    if (! (n = index($i, ">"))) {
        return start + length($i) + 1
    }
    $i = substr($i, n + 1)
    return pop_context(i, start + n)
}
