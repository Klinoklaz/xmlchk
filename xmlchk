#!/usr/bin/env -S gawk -f

BEGIN {
    FS = "<"
    # push when encounter a start tag,
    # pop when encounter an end tag
    t_top = 0
    tag_stack[t_top] = ""
    # track syntax structures that can cross multiple lines
    c_top = 0
    context_stack[c_top] = "d" # doc
}

{
    # TODO:
}

function error(msg, pos) {
    print msg " at line " NR ", char " pos > "/dev/stderr"
    exit 1
}

# find invald character in name.
# didn't cover the full range because unicode sequences are troublesome in awk.
# see https://www.w3.org/TR/xml/#NT-Name
function invalid_name(name) {
    if (name ~ /^[\x00-\x40\x5B-\x5E\x60\x7B-\x7F]/) {
        return 1
    }
    return match(name, /[\x00-\x2C\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/)
}

# find invald character in reference name.
# assume the delimiter '&' is already trimmed
function invalid_ref(ref) {
    # character ref
    if (ref ~ /^#[0-9]+;/ || ref ~ /^#x[0-9a-fA-F]+;/) {
        return 0
    }
    # entity ref
    if (ref ~ /^[\x00-\x40\x5B-\x5E\x60\x7B-\x7F]/ || ! index(";", ref)) {
        return 1
    }
    return match(ref, /[\x00-\x2C\x2F\x3A\x3C-\x40\x5B-\x5E\x60\x7B-\x7F].*?;/)
}

# detect comment end, check '--' inside comment,
# then remove comment from field
function check_comment(i, start) {
    # not inside a comment
    if (context_stack[c_top] != "c") {
        return 0
    }
    # inside a comment
    if ((n = index("--", $i)) == 0) {
        return -1
    }
    m = index("-->", $i)
    if (m == 0 || n < m) {
        error("illegal '--' inside comment", n + start)
    }
    # end of a comment
    $i = substr($i, m + 3)
    delete context_stack[c_top--]
    return m + 2 # trimmed length
}

# check end tag, 2 errors to be considered:
# 1. mismatch with a start tag,
# 2. the tag crossed multiple lines and one of them contains non-space
function check_etag(i, line_start, start) {
    if (context_stack[c_top] != "e") {
        return 0
    }
    if (n = index(">", $i)) {
        tag = substr($i, 1, n - 1)
        $i = substr($i, n + 1)
        delete context_stack[c_top--]
    } else {
        tag = $i
    }
    gsub(/\s*$/, "", tag)
    # line_start == is multi-line && not the initial line
    if (line_start && tag != "") {
        error("malformed end tag", start)
    } else if (! line_start) {
        if (t_top < 1) {
            error("end tag doesn't match any start tag", start)
        }
        if (tag != tag_stack[t_top]) {
            msg = sprintf("mismatch: <%s> </%s>", tag_stack[t_top], tag)
            error(msg, start)
        }
        delete tag_stack[t_top--]
    }
    return n ? n : -1
}

# check start tag
function check_stag(i, start) {
    if (context_stack[c_top] != "s") {
        return 0
    }
    # note empty-element tags end with '/>'
    tag = match($i, /\s|>|\/>/) ? substr($i, 1, RSTART - 1) : $i
    if (tag == "") {
        error("malformed start tag", start)
    }
    if (m = invalid_name(tag)) {
        error("illegal character in tag name", start + m - 1)
    }
    tag_stack[++t_top] = tag

    # deal with attributes
    trimmed = length(tag)
    $i = substr($i, trimmed + 1)
    while (n = match($i, /[^\s]/)) {
        # consume token: trim leading space, check token, remove token from $i
        trimmed += n - 1
        $i = substr($i, n)
        if (context_stack[c_top] == "s") {
            # get out from current tag
            if ($i ~ /^>/) {
                context_stack[c_top] = "t"
                $i = substr($i, 2)
                return ++trimmed
            }
            if ($i ~ /^\/>/) {
                delete context_stack[c_top--]
                $i = substr($i, 3)
                return trimmed + 2
            }
            # encountered attr name
            context_stack[++c_top] = "a"
        }
        # extract attr name
        if (context_stack[c_top] == "a") {
            att_name = match($i, /[\s=]/) ? substr($i, 1, RSTART - 1) : $i
            if (att_name == "") {
                error("malformed attribute", start + trimmed)
            }
            if (m = invalid_name(att_name)) {
                error("illegal character in attribute name", start + trimmed + m - 1)
            }
            t = length(att_name) + 1
            trimmed += t
            $i = substr($i, t + 1)
            context_stack[c_top] = "l" # now at left side of '='
        }
        # wait for an '='
        if (context_stack[c_top] == "l") {
            if ($i !~ /^=/) {
                error("expecting '=' after attribute name", start + trimmed)
            }
            trimmed++
            $i = substr($i, 2)
            context_stack[c_top] = "r" # now at right side of '='
        }
        # wait for a quote
        if (context_stack[c_top] == "r") {
            if ($i !~ /^["']/) {
                error("unquoted attribute value", start + trimmed)
            }
            context_stack[c_top] = substr($i, 1, 1) # inside attr value
            trimmed++
            $i = substr($i, 2)
        }
        # extract attr value
        if (context_stack[c_top] == "'" || context_stack[c_top] == "\"") {
            delimiter = context_stack[c_top]
            if (t = index(delimiter, $i)) {
                val = substr($i, 1, t - 1)
                delete context_stack[c_top--]
            } else {
                val = $i
                t = length($i)
            }
            check_ref(val, start + trimmed)
            trimmed += t
            $i = substr($i, t + 1)
            if ($i !~ /^(\s|>|\/>|$)/) {
                error("attribute list not separated by space", start + trimmed)
            }
        }
    }
    return -1
}

# check for illegal '&' and ']]>' inside char data
function check_text(i, start) {
    if (context_stack[c_top] != "t") {
        return 0
    }
    if ((n = index("]]>", $i))) {
        error("CDATA end delimiter inside text", start + n - 1)
    }
    check_ref($i, start)
    return -1
}

# check for invalid '&' in char data or attr value
function check_ref(data, start) {
    n = split(data, arr, "&")
    pos = length(arr[1])
    for (i = 2; i <= n; i++) {
        if (m = invalid_ref(arr[i])) {
            error("bad reference", start + pos + m - 1)
        }
        pos += length(arr[i]) + 1
    }
}

# skip PI/prolog
function skip_pi(i, line_start, start) {
    if (context_stack[c_top] != "?") {
        return 0
    }
    if (show_igr) {
        if (start) {
            printf "line %d, char %d: <%s", NR, start, $i
        } else if (line_start) {
            printf "line %d: %s", NR, $i
        } else {
            printf "<%s", $i
        }
    }
    if ((n = index("?>", $i)) == 0) {
        return -1
    }
    $i = substr($i, n + 2)
    delete context_stack[c_top--]
    return n + 1 # trimmed length
}

# skip DTD/CDATA
function skip_dtd(i, line_start, start) {
    # note that DTD can have comments in its interior
    if (context_stack[c_top] != "!" || (! line_start && $i ~ /^!--/)) {
        return 0
    }
    if (show_igr) {
        if (start) {
            printf "line %d, char %d: <%s", NR, start, $i
        } else if (line_start) {
            printf "line %d: %s", NR, $i
        } else {
            printf "<%s", $i
        }
    }
    if (! line_start) {
        context_stack[++c_top] = "!"
    }
    # get out of DTD's nested sub-structures
    skipped = 0
    while ((n = index(">", $i)) && context_stack[c_top] == "!") {
        skipped += n
        $i = substr($i, n + 1)
        delete context_stack[c_top--]
    }
    if (context_stack[c_top] == "!") {
        return -1
    }
    return skipped # trimmed length
}
