#!/usr/bin/env -S gawk -f

# copyright (c) 2025 klinoklaz infentrilnuk@yandex.com
# published under MIT license

# xmlchk v0.1.4
# XML syntax validator, requires gawk version >= 4.0

BEGIN {
    # context codes
    C_COMMENT = "c"
    C_START_TAG = "s"
    C_ATT_LIST = "a"
    C_ATT_NAME = "n"
    C_ATT_EQ = "="
    C_ATT_QUOTE = "q"
    C_ATT_VALUE = "\""
    C_ATT_VALUE_ = "'"
    C_TEXT = "t"
    C_END_TAG = "e"
    C_END_SPACE = " "
    C_PI_TARGET = "?"
    C_PI_BODY = "i"
    C_DTD = "!"
    C_DOCUMENT = "d"

    FS = "<"
    unique_attr[1] = 0 # attr name duplication detector
    end_of_root = 0 # multi-root detector
    original_record = ""
    # push when encounter a start tag,
    # pop when encounter an end tag
    t_top = 0
    tag_stack[t_top] = ""
    tag_begin_at[t_top][1] = 0
    # track parsing context
    c_top = 0
    context_stack[c_top] = C_DOCUMENT
    context_begin_at[c_top][1] = 0
}

{
    original_record = $0
    start = next_token(1, 1) # left side of the delimiter '<'

    for (i = 2; i <= NF; i++) { # WARNING: i is global, don't ever reuse
        ctx = context_stack[c_top]
        # '<' is a valid character in comment/PI,
        # so both can cross multiple fields
        if (ctx == C_COMMENT || ctx == C_PI_BODY) {
            start = next_token(i, start)
            continue
        }
        # DTD can have comments in its interior,
        # if it's not a comment, then assume it's DTD subset
        if (ctx == C_DTD && $i !~ /^!--/) {
            start = push_context(C_DTD, i, start)
            continue
        }
        # now at right side of the delimiter '<'
        if (ctx != C_TEXT && ctx != C_DOCUMENT && ctx != C_DTD) {
            error("unexpected '<' inside another tag", start - 1)
        }

        switch ($i) {
        case /^!--/:
            # trim leading '!--'
            # to avoid interfering with check_comment()
            $i = substr($i, 4)
            start = push_context(C_COMMENT, i, start + 3)
            continue
        case /^!/:
            start = push_context(C_DTD, i, start)
            continue
        case /^\?/:
            # same logic as '!--'
            $i = substr($i, 2)
            start = push_context(C_PI_TARGET, i, start + 1)
            continue
        case /^\//:
            # check_end_tag() assumes leading '/' being trimmed
            $i = substr($i, 2)
            start = push_context(C_END_TAG, i, start + 1, 1)
            continue
        default:
            start = push_context(C_START_TAG, i, start)
            continue
        }
    }
}

ENDFILE	{
    if (t_top) {
        error(sprintf("unexpected EOF, element not closed by end tag " \
            "(started at line %d, char %d: <%s>)",
            tag_begin_at[t_top][1], tag_begin_at[t_top][2], tag_stack[t_top]), start)
    }
    if (c_top) {
        begin_at = context_begin_at[c_top][2]
        ctx = context_stack[c_top]
        # calc the position of '<'
        begin_at = ctx == C_COMMENT \
            ? begin_at - 4 \
            : (ctx == C_PI_TARGET || ctx == C_END_TAG ? begin_at - 2 : begin_at - 1)
        error(sprintf("unexpected EOF, syntax structure not closed " \
            "(started at line %d, char %d)",
            context_begin_at[c_top][1], begin_at), start)
    }
}

# extract syntax structures from beginning of field `i` according to context,
# check the syntax, then remove it from $i.
# return a non-zero value indicates current char position in original $0
function next_token(i, start) {
    switch (context_stack[c_top]) {
    case "c": # C_COMMENT
        return check_comment(i, start)
    case "s": # C_START_TAG
        return check_start_tag(i, start)
    case "a": # C_ATT_LIST
        return check_att_list(i, start)
    case "n": # C_ATT_NAME
        return check_att_name(i, start)
    case "=": # C_ATT_EQ
        return check_att_equal(i, start)
    case "q": # C_ATT_QUOTE
        return check_att_quote(i, start)
    case "'": # C_ATT_VALUE_
    case "\"": # C_ATT_VALUE
        return check_att_value(i, start)
    case "t": # C_TEXT
        return check_text(i, start)
    case "e": # C_END_TAG
        return check_end_tag(i, start)
    case " ": # C_END_SPACE
        return check_end_space(i, start)
    case "?": # C_PI_TARGET
        return check_pi_target(i, start)
    case "i": # C_PI_BODY
        return check_pi_body(i, start)
    case "!": # C_DTD
        return skip_dtd(i, start)
    case "d": # C_DOCUMENT
        if (match($i, /\S/)) {
            start += RSTART - 1
            error("text outside the root element", start)
        }
        return start + length($i) + 1
    default:
        error("invalid context: "context_stack[c_top], start)
    }
}

# will be called inside the check functions,
# essentially makes next_token() an indirect recursion
function push_context(context, i, start, is_replace) {
    if (! is_replace) {
        c_top++
    }
    context_stack[c_top] = context
    context_begin_at[c_top][1] = FNR
    context_begin_at[c_top][2] = start
    return next_token(i, start)
}

# same as push_context()
function pop_context(i, start) {
    delete context_stack[c_top]
    delete context_begin_at[c_top--]
    return next_token(i, start)
}

function push_tag(tag, start) {
    tag_stack[++t_top] = tag
    tag_begin_at[t_top][1] = FNR
    tag_begin_at[t_top][2] = start - 1 # position of '<'
}

function pop_tag(no_check, tag, start) {
    if (! no_check && t_top < 1) {
        error("end tag doesn't match any start tag", start)
    }
    if (t_top == 1) {
        end_of_root = 1
    }
    if (! no_check && tag != tag_stack[t_top]) {
        error(sprintf("<%s> at line %d, char %d mismatches with </%s>",
            tag_stack[t_top], tag_begin_at[t_top][1], tag_begin_at[t_top][2], tag), start)
    }
    delete tag_stack[t_top]
    delete tag_begin_at[t_top--]
}

function error(msg, start) {
    printf "%s: line %d, char %d: %s\n", FILENAME, FNR, start, msg > "/dev/stderr"
    printf "%s: line %d:\t%s\n",
        FILENAME, FNR, substr(original_record, start - 9, 20) > "/dev/stderr"
    width = start < 10 ? start : 10
    printf "%s: line %d:\t%"width"s\n", FILENAME, FNR, "^" > "/dev/stderr"
    c_top = t_top = 0 # skip the ENDFILE block
    exit 1
}

# find invald character in name.
# didn't cover the full range because unicode sequences are troublesome in awk.
# see https://www.w3.org/TR/xml/#NT-Name
function invalid_name(name) {
    if (name ~ /^[\x00-\x40\x5B-\x5E\x60\x7B-\x7F]/) {
        return 1
    }
    # 'ns:na:me' should be invalid, 'ns:name' should be valid
    sub(/:/, "c", name) # get rid of first colon
    return match(name, /[\x00-\x2C\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/)
}

# find invald character in reference name.
# assume the delimiter '&' is already trimmed
function invalid_ref(ref) {
    # character ref
    if (ref ~ /^#[0-9]+;/ || ref ~ /^#x[0-9a-fA-F]+;/) {
        return 0
    }
    # entity ref
    if (ref ~ /^[\x00-\x40\x5B-\x5E\x60\x7B-\x7F]/ || ! (semi = index(ref, ";"))) {
        return 1
    }
    # everything before first ';' is the name part
    ref = substr(ref, 1, semi - 1)
    return match(ref, /[\x00-\x2C\x2F\x3A\x3C-\x40\x5B-\x5E\x60\x7B-\x7F]/)
}

function check_comment(i, start) {
    # can't get out yet, continue with next field or line
    if (! (dash = index($i, "--"))) {
        return start + length($i) + 1
    }
    cmt_end = index($i, "-->")
    # note '---->' is invalid but '--->' is fine
    if (! cmt_end || dash < cmt_end - 1) {
        error("illegal '--' inside comment", start + dash - 1)
    }
    $i = substr($i, cmt_end + 3)
    return pop_context(i, start + cmt_end + 3)
}

# start tag ::= '<name(\s+attribute)*>'
# this checks the '<name' part
function check_start_tag(i, start) {
    if (end_of_root) {
        error("start tag outside the root element", start - 1)
    }
    # note empty-element tags end with '/>'
    if (match($i, /\s|>|\/>/)) {
        start_tag = substr($i, 1, RSTART - 1)
        tag_len = RSTART - 1
    } else {
        start_tag = $i
        tag_len = length($i)
    }
    if (start_tag == "") {
        error("malformed start tag", start)
    }
    if (inv = invalid_name(start_tag)) {
        error("illegal character in tag name", start + inv - 1)
    }
    push_tag(start_tag, start)
    $i = substr($i, tag_len + 1)
    return push_context(C_ATT_LIST, i, start + tag_len, 1)
}

# this checks the '(\s+attribute)*>' part of start tag
function check_att_list(i, start) {
    # trim leading spaces
    start += length($i)
    sub(/^\s*/, "", $i)
    start -= length($i)
    if ($i == "") {
        return start + 1
    }
    # try to get out from current tag
    if (substr($i, 1, 1) == ">") {
        $i = substr($i, 2)
        delete unique_attr
        return push_context(C_TEXT, i, ++start, 1)
    }
    if (substr($i, 1, 2) == "/>") {
        pop_tag(1)
        $i = substr($i, 3)
        delete unique_attr
        return pop_context(i, start + 2)
    }
    # encounter attribute name
    return push_context(C_ATT_NAME, i, start)
}

function check_att_name(i, start) {
    # assume no leading space
    if (match($i, /\s|=/)) {
        att_name = substr($i, 1, RSTART - 1)
        att_len = RSTART - 1
    } else {
        att_name = $i
        att_len = length($i)
    }
    if (att_name == "") {
        error("malformed attribute", start)
    }
    if (inv = invalid_name(att_name)) {
        error("illegal character in attribute name", start + inv - 1)
    }
    if (unique_attr[att_name]) {
        error("duplicated attribute name", start)
    }
    unique_attr[att_name] = 1
    $i = substr($i, att_len + 1)
    # now at left side of '='
    return push_context(C_ATT_EQ, i, start + att_len, 1)
}

# wait for an '='
function check_att_equal(i, start) {
    start += length($i)
    sub(/^\s*/, "", $i)
    start -= length($i)
    if ($i == "") {
        return start + 1
    }
    if (substr($i, 1, 1) != "=") {
        error("expecting '=' after attribute name", start)
    }
    $i = substr($i, 2)
    # now at right side of '='
    return push_context(C_ATT_QUOTE, i, ++start, 1)
}

# wait for a quote
function check_att_quote(i, start) {
    start += length($i)
    sub(/^\s*/, "", $i)
    start -= length($i)
    if ($i == "") {
        return start + 1
    }
    delimiter = substr($i, 1, 1)
    if (delimiter != C_ATT_VALUE && delimiter != C_ATT_VALUE_) {
        error("unquoted attribute value", start)
    }
    $i = substr($i, 2)
    # now inside attr value
    return push_context(delimiter, i, ++start, 1)
}

function check_att_value(i, start) {
    if (quote = index($i, context_stack[c_top])) {
        val_len = quote - 1
        val = substr($i, 1, val_len)
    } else {
        val = $i
        val_len = length($i)
    }
    check_ref(val, start)
    start += val_len + 1
    if (! quote) {
        return start
    }
    # trim the value string and also the quote
    $i = substr($i, val_len + 2)
    if ($i !~ /^(\s|>|\/>|$)/) {
        error("attribute list not separated by space", start)
    }
    return pop_context(i, start)
}

# check for illegal '&' and ']]>' inside char data
function check_text(i, start) {
    if ((cd = index($i, "]]>"))) {
        error("CDATA end delimiter inside text", start + cd - 1)
    }
    check_ref($i, start)
    return start + length($i) + 1
}

# check for invalid '&' in char data or attr value
function check_ref(data, start) {
    split(data, ref_arr, "&")
    start += length(ref_arr[1]) + 1
    delete ref_arr[1]
    for (k in ref_arr) {
        if (inv = invalid_ref(ref_arr[k])) {
            error("bad reference", start + inv - 1)
        }
        start += length(ref_arr[k]) + 1
    }
}

function check_end_tag(i, start) {
    tag = (gt_sign = index($i, ">")) \
        ? substr($i, 1, gt_sign - 1) \
        : $i
    sub(/\s*$/, "", tag)
    pop_tag(0, tag, start)
    if (gt_sign) {
        $i = substr($i, gt_sign + 1)
        return pop_context(i, start + gt_sign)
    }
    # inside the trailing space
    start += length($i) + 1
    $i = ""
    return push_context(C_END_SPACE, i, start, 1)
}

# end tag ::= </name\s*>, check for the \s* part
function check_end_space(i, start) {
    end_space = (tag_end = index($i, ">")) \
        ? substr($i, 1, tag_end - 1) \
        : $i
    if (match(end_space, /\S/)) {
        error("malformed end tag", start + RSTART - 1)
    }
    if (! tag_end) {
        return start + length($i) + 1
    }
    $i = substr($i, tag_end + 1)
    return pop_context(i, start + tag_end)
}

function check_pi_target(i, start) {
    # assume the leading '<?' already trimmed
    if (match($i, /\s|\?>/)) {
        pi_sep = RSTART
        pi_target = substr($i, 1, pi_sep - 1)
    } else {
        pi_sep = length($i) + 1
        pi_target = $i
    }
    if (pi_target == "") {
        error("malformed PI", start)
    }
    # TODO: full XML declaration syntax check
    if (pi_target == "xml" && (FNR != 1 || start != 3)) {
        error("XML declaration at wrong place", start - 2)
    }
    if (inv = invalid_name(pi_target)) {
        error("illegal character in PI target", start + inv - 1)
    }
    start += pi_sep - 1
    $i = substr($i, pi_sep)
    if (substr($i, 1, 2) == "?>") {
        $i = substr($i, 3)
        return pop_context(i, start + 2)
    }
    # this detects the second '<' in '<?tar<get'
    if ($i == "" && NF > i) {
        error("illegal character in PI target", start)
    }
    # now inside the instruction part
    return push_context(C_PI_BODY, i, start, 1)
}

# everything is valid in the remaining part of PI,
# nothing to really check, just wait for '?>'
function check_pi_body(i, start) {
    if (! (pi_end = index($i, "?>"))) {
        return start + length($i) + 1
    }
    $i = substr($i, pi_end + 2)
    return pop_context(i, start + pi_end + 1)
}

# skip DTD/CDATA
function skip_dtd(i, start) {
    if (! (dtd_end = index($i, ">"))) {
        return start + length($i) + 1
    }
    $i = substr($i, dtd_end + 1)
    return pop_context(i, start + dtd_end)
}
